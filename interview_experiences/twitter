https://leetcode.com/discuss/interview-question/1498102/twitter-0a-2021-questions-and-previous-all-leetcode-resources

https://leetcode.com/discuss/interview-question/859662/twitter-phone-interview


=======================

https://leetcode.com/discuss/interview-question/374846/Twitter-or-OA-2019-or-University-Career-Fair

https://leetcode.com/discuss/interview-question/406638/Twitter-or-OA-2019-or-Balanced-Sales-Array

======================

Good problems :

https://leetcode.com/problems/tweet-counts-per-frequency/discuss/1511282/Simple-Java-Solution-with-HashMap-of-TreeSet-(cheating-using-Double)

https://leetcode.com/problems/finding-the-users-active-minutes/


https://leetcode.com/problems/minimum-moves-to-equal-array-elements
    Let's explain it in a clear and short manner:
    suppose there're k elements, the sum of original array is s, the minimum move is m, eventually all the elements become e, we know each move contributes (k-1) to the sum, so we have:
    s + (k-1)*m = k*e
    for the minimum element min, it must be added m times, i.e.
    min + m = e
    The two equations above would give us m = s - k*min = sum(array) - array.len * array[0]

    - Coding approach : Check Approach #5 Using Math[Accepted]
